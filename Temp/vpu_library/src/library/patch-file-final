diff --git a/vpu_library/src/library/vpu_as.c b/vpu_library/src/library/vpu_as.c
index f76a8cf..d6119b9 100644
--- a/vpu_library/src/library/vpu_as.c
+++ b/vpu_library/src/library/vpu_as.c
@@ -227,6 +230,10 @@ int decoder_parse(struct decode *dec)
                 break;
         }
     }
+    
+    dec->lastPicWidth = initinfo.picWidth;
+    dec->lastPicHeight = initinfo.picHeight;
+
     printf("Decoder: width = %d, height = %d, frameRateRes = %d, frameRateDiv = %d, count = %u\n",
             initinfo.picWidth, initinfo.picHeight,
             initinfo.frameRateRes, initinfo.frameRateDiv,
@@ -240,6 +247,11 @@ int decoder_parse(struct decode *dec)
     else
         dec->regfbcount = dec->minfbcount + extended_fbcount;
 
+    printf("Minfb: %d , Extfb: %d",dec->minfbcount, extended_fdbount);
+
+    origPicWidth = initinfo.picWidth;
+    origPicHeight = initinfo.picHeight;
+
     dec->picwidth = ((initinfo.picWidth + 15) & ~15);
 
     align = 16;
@@ -247,6 +259,7 @@ int decoder_parse(struct decode *dec)
         align = 32;
 
     dec->picheight = ((initinfo.picHeight + align - 1) & ~(align - 1));
+
     if ((dec->picwidth == 0) || (dec->picheight == 0))
         return -1;
 
@@ -283,6 +296,26 @@ int decoder_allocate_framebuffer(struct decode *dec){
     struct frame_buf **pfbpool;
     int stride;
 
+    if (rot_en || dering_en || tiled2LinearEnable) {
+        /*
+         * At least 1 extra fb for rotation(or dering) is needed, two extrafb
+         * are allocated for rotation if path is V4L,then we can delay 1 frame
+         * de-queue from v4l queue to improve performance.
+         */
+        dec->rot_buf_count = 1;// TODO Depends on Destination Scheme
+        /*
+         * Need more buffers for V4L2 performance mode
+         * otherwise, buffer will be queued twice
+         */
+        dec->rot_buf_count = dec->regfbcount - dec->minfbcount + 1;
+        dec->extrafb += dec->rot_buf_count;
+        dec->post_processing = 1;
+    }
+
+    if(deblock_en){
+        dec->extrafb++;
+    }
+
     totalfb = regfbcount + dec->extrafb;// TODO Check
     printf("Total FrameBuffers Used: %d\n",totalfb);
 
@@ -305,7 +338,7 @@ int decoder_allocate_framebuffer(struct decode *dec){
     if (dec->cmdl->mapType == LINEAR_FRAME_MAP) {
         /* All buffers are linear */
         for (i = 0; i < totalfb; i++) {
-            pfbpool[i] = framebuf_alloc(dec->cmdl->format, dec->mjpg_fmt,dec->stride, dec->picheight, mvCol);// :TODO
+            pfbpool[i] = framebuf_alloc(&dec->fbpool[i], dec->cmdl->format, dec->mjpg_fmt,dec->stride, dec->picheight, mvCol);//:TODO
             if (pfbpool[i] == NULL){
                 printf("pfbpool[%d] == NULL\n",i);
                 // :TODO Free pfbpool
@@ -327,8 +363,6 @@ int decoder_allocate_framebuffer(struct decode *dec){
 
     stride = ((dec->stride + 15) & ~15);
 
-    printf ("%s - Line: %d -> Done allocation\n","decoder_allocate_framebuffer", __LINE__);
-
     bufinfo.avcSliceBufInfo.bufferBase = dec->phy_slice_buf;
     bufinfo.avcSliceBufInfo.bufferSize = dec->phy_slicebuf_size;
 
@@ -336,6 +370,14 @@ int decoder_allocate_framebuffer(struct decode *dec){
     bufinfo.maxDecFrmInfo.maxMbX = dec->stride / 16;
     bufinfo.maxDecFrmInfo.maxMbY = dec->picheight / 16;
     bufinfo.maxDecFrmInfo.maxMbNum = dec->stride * dec->picheight / 256;
+    
+    /* For H.264, we can overwrite initial delay calculated from syntax.
+     * delay can be 0,1,... (in unit of frames)
+     * Set to -1 or do not call this command if you don't want to overwrite it.
+     * Take care not to set initial delay lower than reorder depth of the clip,
+     * otherwise, display will be out of order. */
+    vpu_DecGiveCommand(handle, DEC_SET_FRAME_DELAY, &delay);
+
     ret = vpu_DecRegisterFrameBuffer(handle, fb, dec->regfbcount, stride, &bufinfo);
     if (ret != RETCODE_SUCCESS) {
         err_msg("Register frame buffer failed, ret=%d\n", ret);
@@ -408,12 +450,11 @@ int decoder_start(struct decode *dec)
         deblock_fb->bufCb = pfb->addrCb;
         deblock_fb->bufCr = pfb->addrCr;
     }
-    
+ 
     //while (1) {
 
         if (deblock_en) {   
-            ret = vpu_DecGiveCommand(handle, DEC_SET_DEBLOCK_OUTPUT,
-                    (void *)deblock_fb);
+            ret = vpu_DecGiveCommand(handle, DEC_SET_DEBLOCK_OUTPUT,(void *)deblock_fb);
             if (ret != RETCODE_SUCCESS) {
                 err_msg("Failed to set deblocking output\n");
                 return -1;  
@@ -631,7 +669,7 @@ int main( void )
 int main(void)
 {
     struct decode *dec;
-    struct cmd_line cmdl; // :TODO Set the Structure before Decode Open
+    struct cmd_line cmdl = {0}; // :TODO Set the Structure before Decode Open
     vpu_mem_desc mem_desc = {0};
     vpu_mem_desc ps_mem_desc = {0};
     vpu_mem_desc slice_mem_desc = {0};
@@ -646,8 +684,6 @@ int main(void)
     dummy_fd = open("/sda/dummy",O_RDWR,0); // TODO: remove it. Just to invoke the VFS to open before other Open calls
     printf("Dummy fileFD: %d\n",dummy_fd);
 
-    framebuf_init();
-    printf("framebuf initialised!");
     ret = vpu_Init();
     if(ret != RETCODE_SUCCESS){
         err_msg("VPU INIT Failed! retured %d\n",ret);
@@ -675,7 +711,6 @@ int main(void)
 
     dec->reorderEnable = 0;
     dec->tiled2LinearEnable = 0;
-   
 
     // :TODO Hard Coding Cmd Line Args
     cmdl.format = STD_AVC;
@@ -795,7 +833,6 @@ int main(void)
     }
 
     printf("END!!!\n");
-
     return 0;
 }
 #endif
diff --git a/vpu_library/src/library/vpu_lib/vpu_lib.c b/vpu_library/src/library/vpu_lib/vpu_lib.c
index 92c4a26..adcebd7 100644
--- a/vpu_library/src/library/vpu_lib/vpu_lib.c
+++ b/vpu_library/src/library/vpu_lib/vpu_lib.c
@@ -408,34 +406,25 @@ RetCode vpu_DecGetInitialInfo(DecHandle handle, DecInitialInfo * info)
     info->frameRateDiv = VpuReadReg(RET_DEC_SEQ_FRATE_DR);
     info->bitRate = VpuReadReg(RET_DEC_SEQ_BIT_RATE);
 
-
-
     info->minFrameBufferCount = VpuReadReg(RET_DEC_SEQ_FRAME_NEED);
     info->frameBufDelay = VpuReadReg(RET_DEC_SEQ_FRAME_DELAY);
 
-    if (inst->codecMode == AVC_DEC) {
-        val = VpuReadReg(RET_DEC_SEQ_CROP_LEFT_RIGHT);
-        val2 = VpuReadReg(RET_DEC_SEQ_CROP_TOP_BOTTOM);
-        if (val == 0 && val2 == 0) {
-            info->picCropRect.left = 0;
-            info->picCropRect.right = 0;
-            info->picCropRect.top = 0;
-            info->picCropRect.bottom = 0;
-        }else {
-            info->picCropRect.left = ((val >> 16) & 0xFFFF);
-            info->picCropRect.right = info->picWidth - ((val & 0xFFFF));
-            info->picCropRect.top = ((val2 >> 16) & 0xFFFF);
-            info->picCropRect.bottom = info->picHeight - ((val2 & 0xFFFF));
-        }
-        val = info->picWidth * info->picHeight;
-        info->normalSliceSize = (val * 3 / 2) / 1024 / 4;
-        info->worstSliceSize = ((val / 256) * 3200 / 8  + 512)/ 1024;
-    } else {
+    val = VpuReadReg(RET_DEC_SEQ_CROP_LEFT_RIGHT);
+    val2 = VpuReadReg(RET_DEC_SEQ_CROP_TOP_BOTTOM);
+    if (val == 0 && val2 == 0) {
         info->picCropRect.left = 0;
         info->picCropRect.right = 0;
         info->picCropRect.top = 0;
         info->picCropRect.bottom = 0;
+    }else {
+        info->picCropRect.left = ((val >> 16) & 0xFFFF);
+        info->picCropRect.right = info->picWidth - ((val & 0xFFFF));
+        info->picCropRect.top = ((val2 >> 16) & 0xFFFF);
+        info->picCropRect.bottom = info->picHeight - ((val2 & 0xFFFF));
     }
+    val = info->picWidth * info->picHeight;
+    info->normalSliceSize = (val * 3 / 2) / 1024 / 4;
+    info->worstSliceSize = ((val / 256) * 3200 / 8  + 512)/ 1024;
 
     val = VpuReadReg(RET_DEC_SEQ_HEADER_REPORT);
     info->profile = (val >> 0) & 0xFF;
@@ -450,7 +439,6 @@ RetCode vpu_DecGetInitialInfo(DecHandle handle, DecInitialInfo * info)
 
     val = VpuReadReg(RET_DEC_SEQ_ASPECT);
     info->aspectRateInfo = val;
-
    
     info->streamInfoObtained = 1;
 
@@ -502,7 +490,7 @@ RetCode vpu_DecStartOneFrame(DecHandle handle, DecParam * param)
     CodecInst *inst;
     DecInfo *pDecInfo;
     DecParam *pDecParam;
-    Uint32 reg = 0;
+    Uint32 reg = 0, rotMir = 0;
     RetCode ret;
 
     ENTER_FUNC("vpu_DecStartOneFrame");
@@ -534,14 +522,22 @@ RetCode vpu_DecStartOneFrame(DecHandle handle, DecParam * param)
     // Ignoring logtime TODO
 
     SetGDIRegs(&pDecInfo->sTiledInfo);
+    
+    if (pDecInfo->tiledLinearEnable) {// TODO CHECK
+	rotMir |= 0x10;
+    }
+
+    if (pDecInfo->deringEnable) {// TODO CHECK
+	rotMir |= 0x20; /* Enable Dering Filter */
+    }
+
+    VpuWriteReg(CMD_DEC_PIC_ROT_MODE, rotMir);// TODO CHECK
 
     // ignoring mx6x_mjpg
 
     // ignoring tiled enable
     // ignoring dering enable
 
-    
-
     reg |= (1 << 10); /* hardcode to use interrupt disable mode  */
 
     /* if iframeSearch is Enable, other bit is ignored. */
@@ -574,7 +568,7 @@ RetCode vpu_DecStartOneFrame(DecHandle handle, DecParam * param)
     VpuWriteReg(BIT_AXI_SRAM_USE, reg);
     BitIssueCommand(inst, PIC_RUN);
     ppendingInst = inst;
-
+    
     EXIT_FUNC("vpu_DecStartOneFrame");
     return RETCODE_SUCCESS;
 }
@@ -656,9 +650,6 @@ RetCode vpu_DecGiveCommand(DecHandle handle, CodecCommand cmd, void *param)
     pDecInfo = &inst->CodecInfo.decInfo;
 
     switch (cmd) {
-        
-          
-
         case DEC_SET_SPS_RBSP:
             {
                 if (inst->codecMode != AVC_DEC) {
@@ -682,20 +673,17 @@ RetCode vpu_DecGiveCommand(DecHandle handle, CodecCommand cmd, void *param)
                 SetParaSet(handle, 1, param);
                 break;
             }
-     
         case ENABLE_DERING:
             {       
                 
                 pDecInfo->deringEnable = 1;
                 break;
             }
-
         case DISABLE_DERING:
             {   
                 pDecInfo->deringEnable = 0;
                 break;
             }
-
         case SET_DBK_OFFSET :
             {   
                 DbkOffset dbkOffset;
